# All You Need to Know in Function Call

###  1 Function Call allows user to connect models to external tools and systems

###  2 Use cases are fetch data/take actions/perform computation

###  3 The lifecycle of a function call
![image](https://github.com/user-attachments/assets/4ebe64a3-9d2e-4138-8dbf-e5a6465799d6)

### 4 Tips and best practices

##### 4.1 Turn on Structured Outputs by setting strict: "true"
When Structured Outputs is turned on, the arguments generated by the model for function calls will reliably match the JSON Schema that you provide.

If you are not using Structured Outputs, then the structure of arguments is not guaranteed to be correct, so we recommend the use of a validation library like Pydantic to first verify the arguments prior to using them.

##### 4.2 Name functions intuitively, with detailed descriptions

If you find the model does not generate calls to the correct functions, you may need to update your function names and descriptions so the model more clearly understands when it should select each function. Avoid using abbreviations or acronyms to shorten function and argument names.

You can also include detailed descriptions for when a tool should be called. For complex functions, you should include descriptions for each of the arguments to help the model know what it needs to ask the user to collect that argument.

##### 4.3 Name function parameters intuitively, with detailed descriptions

Use clear and descriptive names for function parameters. For example, specify the expected format for a date parameter (e.g., YYYY-mm-dd or dd/mm/yy) in the description.

##### 4.4 Consider providing additional information about how and when to call functions in your system message

Providing clear instructions in your system message can significantly improve the model's function calling accuracy. For example, guide the model with things like, "Use check_order_status when the user inquires about the status of their order, such as 'Where is my order?' or 'Has my order shipped yet?'". Provide context for complex scenarios, like "Before scheduling a meeting with schedule_meeting, check the user's calendar for availability using check_availability to avoid conflicts."

##### 4.5 Use enums for function arguments when possible

If your use case allows, you can use enums to constrain the possible values for arguments. This can help reduce hallucinations.

For example, say you have an AI assistant that helps with ordering a T-shirt. You likely have a fixed set of sizes for the T-shirt, and you might want the model to output in a specific format. If you want the model to output “s”, “m”, “l”, etc for small, medium, and large, then you could provide those values in the enum, for example:

##### 4.6 Keep the number of functions low for higher accuracy

We recommend that you use no more than 20 functions in a single tool call. Developers typically see a reduction in the model’s ability to select the correct tool once they have between 10-20 tools.

If your use case requires the model to be able to pick between a large number of functions, you may want to explore fine-tuning (learn more) or break out the tools and group them logically to create a multi-agent system.

##### 4.7 Set up evals to act as an aid in prompt engineering your function definitions and system messages

We recommend for non-trivial uses of function calling that you set up a suite of evals that allow you to measure how frequently the correct function is called or correct arguments are generated for a wide variety of possible user messages. Learn more about setting up evals on the OpenAI Cookbook.

You can then use these to measure whether adjustments to your function definitions and system messages will improve or hurt your integration.

##### 4.8 Fine-tuning may help improve accuracy for function calling

Fine-tuning a model can improve performance at function calling for your use case, especially if you have a large number of functions, or complex, nuanced or similar functions.

##### 4.9 The parameters named things like functions and function_call etc are now deprecated. Use tools/tool_choice/tool_calls

###  5 Examples

##### 5.1 Data Retrieval
- Scenario: A chatbot needs to fetch the latest customer data from an internal system when a user asks “who are my top customers?”
- Implementation: Define a functionget_customers(min_revenue: int, created_before: string, limit: int) that retrieves customer data from your internal API. The model can suggest calling this function with the appropriate parameters based on user input.

##### 5.2 Task Automation
- Scenario: An assistant bot schedules meetings based on user preferences and calendar availability.
- Implementation: Define a function scheduleMeeting(date: str, time: str, participants: list) that interacts with a calendar API. The model can suggest the best times and dates to call this function.

##### 5.3 Computational Tasks
- Scenario: A financial application calculates loan payments based on user input.
- Implementation: Define a function calculateLoanPayment(principal: float, interestRate: float, term: int) to perform the necessary calculations. The model can provide the input values for this function.

##### 5.4 Customer Support
- Scenario: A customer support bot assists users by providing the status of their orders.
- Implementation: Define a function getOrderStatus(orderId: str) that retrieves order status information from a database. The model can suggest calling this function with the appropriate order ID parameter based on user input.












